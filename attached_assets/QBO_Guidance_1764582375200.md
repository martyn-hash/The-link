# QuickBooks Online API Integration Guide

A comprehensive guide for integrating QuickBooks Online API with a Node.js/Express backend and React frontend on Replit.

---

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Environment Setup](#environment-setup)
3. [QuickBooks Developer Portal Configuration](#quickbooks-developer-portal-configuration)
4. [Package Installation](#package-installation)
5. [Schema Definition](#schema-definition)
6. [Storage Layer](#storage-layer)
7. [QuickBooks Module](#quickbooks-module)
8. [API Routes](#api-routes)
9. [Common Errors & Solutions](#common-errors--solutions)
10. [Testing the Integration](#testing-the-integration)
11. [Available API Endpoints](#available-api-endpoints)
12. [Production Deployment](#production-deployment)

---

## Prerequisites

- Replit account with a Node.js project
- QuickBooks Developer account (https://developer.intuit.com/)
- QuickBooks Sandbox company (created automatically with dev account)

---

## Environment Setup

### Required Secrets

Add these to your Replit Secrets (Tools → Secrets):

| Secret Name | Description | Example |
|-------------|-------------|---------|
| `QUICKBOOKS_CLIENT_ID` | OAuth 2.0 Client ID from QuickBooks | `ABcFVeSWbOE...` |
| `QUICKBOOKS_CLIENT_SECRET` | OAuth 2.0 Client Secret | `kd8JhT3nF...` |
| `QUICKBOOKS_REDIRECT_URI` | OAuth callback URL | `https://your-app.repl.co/api/oauth/callback` |
| `SESSION_SECRET` | Express session secret (any random string) | `your-random-secret-here` |

### Redirect URI Configuration

**CRITICAL**: The redirect URI must match EXACTLY between:
1. Your `QUICKBOOKS_REDIRECT_URI` secret
2. The "Redirect URIs" list in QuickBooks Developer Portal

**For Replit Development:**
```
https://your-repl-name.your-username.repl.co/api/oauth/callback
```

**For Custom Domain:**
```
https://your-custom-domain.com/api/oauth/callback
```

---

## QuickBooks Developer Portal Configuration

1. Go to https://developer.intuit.com/
2. Create a new app or select existing
3. Navigate to "Keys & credentials"
4. Under "Redirect URIs", add your callback URL
5. Copy Client ID and Client Secret to Replit secrets

### Sandbox vs Production

- **Sandbox**: Use for testing (default in our implementation)
- **Production**: Requires app review by Intuit

The environment is controlled in `server/quickbooks.ts`:
```typescript
const ENVIRONMENT = 'sandbox'; // Change to 'production' for live
```

---

## Package Installation

Install the required npm package:

```bash
npm install node-quickbooks
```

**Note**: `node-quickbooks` is an untyped JavaScript library. We use `// @ts-ignore` to suppress TypeScript errors.

---

## Schema Definition

Create the data model in `shared/schema.ts`:

```typescript
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// User table (if needed for auth)
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// QuickBooks token storage
export const quickbooksTokens = pgTable("quickbooks_tokens", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  realmId: text("realm_id").notNull(),
  accessToken: text("access_token").notNull(),
  refreshToken: text("refresh_token").notNull(),
  tokenExpiry: timestamp("token_expiry").notNull(),
  companyName: text("company_name"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const insertQuickbooksTokenSchema = createInsertSchema(quickbooksTokens).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertQuickbooksToken = z.infer<typeof insertQuickbooksTokenSchema>;
export type QuickbooksToken = typeof quickbooksTokens.$inferSelect;
```

---

## Storage Layer

Create `server/storage.ts` for token management:

```typescript
import { type User, type InsertUser, type QuickbooksToken, type InsertQuickbooksToken } from "@shared/schema";
import { randomUUID } from "crypto";

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // QuickBooks token management
  getQuickbooksToken(): Promise<QuickbooksToken | undefined>;
  saveQuickbooksToken(token: InsertQuickbooksToken): Promise<QuickbooksToken>;
  deleteQuickbooksToken(): Promise<void>;
}

export class MemStorage implements IStorage {
  private users: Map<string, User>;
  private quickbooksToken: QuickbooksToken | undefined;

  constructor() {
    this.users = new Map();
    this.quickbooksToken = undefined;
  }

  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = randomUUID();
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }

  async getQuickbooksToken(): Promise<QuickbooksToken | undefined> {
    return this.quickbooksToken;
  }

  async saveQuickbooksToken(token: InsertQuickbooksToken): Promise<QuickbooksToken> {
    const id = randomUUID();
    const now = new Date();
    this.quickbooksToken = {
      id,
      ...token,
      companyName: token.companyName || null,
      createdAt: now,
      updatedAt: now,
    };
    return this.quickbooksToken;
  }

  async deleteQuickbooksToken(): Promise<void> {
    this.quickbooksToken = undefined;
  }
}

export const storage = new MemStorage();
```

---

## QuickBooks Module

Create `server/quickbooks.ts` - the core OAuth and API logic:

```typescript
// @ts-ignore - no types available for node-quickbooks
import QuickBooks from 'node-quickbooks';
import { storage } from './storage';

const CLIENT_ID = process.env.QUICKBOOKS_CLIENT_ID!;
const CLIENT_SECRET = process.env.QUICKBOOKS_CLIENT_SECRET!;
const REDIRECT_URI = process.env.QUICKBOOKS_REDIRECT_URI!;
const ENVIRONMENT = 'sandbox'; // Change to 'production' for live QuickBooks

// Generate OAuth authorization URL
export function getAuthUri() {
  // For OAuth 2.0, manually construct the authorization URL
  // NOTE: QuickBooks.authorizeUrl() is NOT a valid static method
  const state = Math.random().toString(36).substring(7);
  const scope = 'com.intuit.quickbooks.accounting';
  const baseUrl = 'https://appcenter.intuit.com/connect/oauth2';
  
  const params = new URLSearchParams({
    client_id: CLIENT_ID,
    scope,
    redirect_uri: REDIRECT_URI,
    response_type: 'code',
    state,
  });
  
  return `${baseUrl}?${params.toString()}`;
}

// Exchange authorization code for tokens
export async function exchangeCodeForTokens(code: string, realmId: string) {
  return new Promise<{
    access_token: string;
    refresh_token: string;
    expires_in: number;
  }>((resolve, reject) => {
    QuickBooks.createToken(
      REDIRECT_URI,
      code,
      realmId,
      CLIENT_ID,
      CLIENT_SECRET,
      (err: any, tokens: any) => {
        if (err) {
          reject(err);
        } else {
          resolve(tokens);
        }
      }
    );
  });
}

// Get authenticated QuickBooks client (with auto token refresh)
export async function getQuickBooksClient(): Promise<QuickBooks | null> {
  const tokenData = await storage.getQuickbooksToken();
  
  if (!tokenData) {
    return null;
  }

  // Check if token is expired
  if (new Date() >= tokenData.tokenExpiry) {
    // Refresh the token
    try {
      const newTokens = await refreshAccessToken(tokenData.refreshToken, tokenData.realmId);
      const expiryDate = new Date();
      expiryDate.setSeconds(expiryDate.getSeconds() + newTokens.expires_in);
      
      await storage.saveQuickbooksToken({
        realmId: tokenData.realmId,
        accessToken: newTokens.access_token,
        refreshToken: newTokens.refresh_token,
        tokenExpiry: expiryDate,
        companyName: tokenData.companyName,
      });

      return createClient(newTokens.access_token, tokenData.realmId);
    } catch (error) {
      console.error('Failed to refresh token:', error);
      return null;
    }
  }

  return createClient(tokenData.accessToken, tokenData.realmId);
}

// Create QuickBooks client instance
function createClient(accessToken: string, realmId: string): QuickBooks {
  return new QuickBooks(
    CLIENT_ID,
    CLIENT_SECRET,
    accessToken,
    false, // no token secret for OAuth 2.0
    realmId,
    ENVIRONMENT === 'sandbox', // true for sandbox, false for production
    true, // use the v3 API (debug mode)
    null, // minorversion - null for latest
    '2.0', // OAuth version
    null // refresh token (not needed for individual requests)
  );
}

// Refresh expired access token
async function refreshAccessToken(refreshToken: string, realmId: string) {
  return new Promise<{
    access_token: string;
    refresh_token: string;
    expires_in: number;
  }>((resolve, reject) => {
    QuickBooks.refreshAccessToken(
      refreshToken,
      CLIENT_ID,
      CLIENT_SECRET,
      (err: any, tokens: any) => {
        if (err) {
          reject(err);
        } else {
          resolve(tokens);
        }
      }
    );
  });
}

// Helper function to promisify QuickBooks SDK callback methods
export function queryQuickBooks<T = any>(
  qb: QuickBooks,
  method: string,
  ...args: any[]
): Promise<T> {
  return new Promise((resolve, reject) => {
    const callback = (err: any, result: T) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
    
    // Call the method on the QuickBooks instance
    (qb as any)[method](...args, callback);
  });
}
```

### Key Points About QuickBooks Client Constructor

The `QuickBooks` constructor takes these parameters in order:

```typescript
new QuickBooks(
  consumerKey,        // CLIENT_ID
  consumerSecret,     // CLIENT_SECRET  
  oauthToken,         // access_token
  oauthTokenSecret,   // false for OAuth 2.0
  realmId,            // Company ID from OAuth callback
  useSandbox,         // true for sandbox, false for production
  enableDebugging,    // true to log requests
  minorVersion,       // null for latest API version
  oauthVersion,       // '2.0' for OAuth 2.0
  refreshToken        // null (not needed per-request)
);
```

---

## API Routes

Create `server/routes.ts`:

```typescript
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { getAuthUri, exchangeCodeForTokens, getQuickBooksClient, queryQuickBooks } from "./quickbooks";

export async function registerRoutes(app: Express): Promise<Server> {
  // OAuth initiation - returns authorization URL
  app.get("/api/oauth/connect", (req, res) => {
    try {
      const authUri = getAuthUri();
      res.json({ authUri });
    } catch (error) {
      console.error('OAuth connect error:', error);
      res.status(500).json({ error: 'Failed to generate authorization URL' });
    }
  });

  // OAuth callback - handles redirect from QuickBooks
  app.get("/api/oauth/callback", async (req, res) => {
    try {
      const { code, realmId, state } = req.query;

      if (!code || !realmId) {
        return res.status(400).send('Missing authorization code or realm ID');
      }

      // Exchange code for tokens
      const tokens = await exchangeCodeForTokens(code as string, realmId as string);
      
      // Calculate token expiry
      const expiryDate = new Date();
      expiryDate.setSeconds(expiryDate.getSeconds() + tokens.expires_in);

      // Create QuickBooks client with fresh tokens to get company info
      const CLIENT_ID = process.env.QUICKBOOKS_CLIENT_ID!;
      const CLIENT_SECRET = process.env.QUICKBOOKS_CLIENT_SECRET!;
      const QuickBooks = require('node-quickbooks');
      
      const qb = new QuickBooks(
        CLIENT_ID,
        CLIENT_SECRET,
        tokens.access_token,
        false,
        realmId as string,
        true, // sandbox
        true, // debug
        null,
        '2.0',
        null
      );

      // Fetch company name
      let companyName = 'Unknown';
      try {
        const companyInfo = await queryQuickBooks(qb, 'getCompanyInfo', realmId);
        companyName = companyInfo.CompanyInfo?.CompanyName || 'Unknown';
      } catch (error) {
        console.error('Failed to fetch company info:', error);
      }

      // Save tokens to storage
      await storage.saveQuickbooksToken({
        realmId: realmId as string,
        accessToken: tokens.access_token,
        refreshToken: tokens.refresh_token,
        tokenExpiry: expiryDate,
        companyName,
      });

      // Redirect to frontend with success
      res.redirect('/?connected=true');
    } catch (error) {
      console.error('OAuth callback error:', error);
      res.redirect('/?error=oauth_failed');
    }
  });

  // Get connection status
  app.get("/api/connection/status", async (req, res) => {
    try {
      const tokenData = await storage.getQuickbooksToken();
      
      if (!tokenData) {
        return res.json({ connected: false });
      }

      const isExpired = new Date() >= tokenData.tokenExpiry;
      
      res.json({
        connected: !isExpired,
        companyName: tokenData.companyName,
        realmId: tokenData.realmId,
        lastSync: tokenData.updatedAt,
      });
    } catch (error) {
      console.error('Status check error:', error);
      res.status(500).json({ error: 'Failed to check connection status' });
    }
  });

  // Disconnect
  app.post("/api/connection/disconnect", async (req, res) => {
    try {
      await storage.deleteQuickbooksToken();
      res.json({ success: true });
    } catch (error) {
      console.error('Disconnect error:', error);
      res.status(500).json({ error: 'Failed to disconnect' });
    }
  });

  // Fetch customers
  app.get("/api/data/customers", async (req, res) => {
    try {
      const qb = await getQuickBooksClient();
      
      if (!qb) {
        return res.status(401).json({ error: 'Not connected to QuickBooks' });
      }

      const customers = await queryQuickBooks(qb, 'findCustomers', {
        Active: true,
        limit: 100,
      });

      res.json({
        data: customers.QueryResponse?.Customer || [],
        count: customers.QueryResponse?.Customer?.length || 0,
      });
    } catch (error) {
      console.error('Fetch customers error:', error);
      res.status(500).json({ error: 'Failed to fetch customers' });
    }
  });

  // Fetch invoices
  app.get("/api/data/invoices", async (req, res) => {
    try {
      const qb = await getQuickBooksClient();
      
      if (!qb) {
        return res.status(401).json({ error: 'Not connected to QuickBooks' });
      }

      const invoices = await queryQuickBooks(qb, 'findInvoices', {
        limit: 100,
      });

      res.json({
        data: invoices.QueryResponse?.Invoice || [],
        count: invoices.QueryResponse?.Invoice?.length || 0,
      });
    } catch (error) {
      console.error('Fetch invoices error:', error);
      res.status(500).json({ error: 'Failed to fetch invoices' });
    }
  });

  // Fetch items
  app.get("/api/data/items", async (req, res) => {
    try {
      const qb = await getQuickBooksClient();
      
      if (!qb) {
        return res.status(401).json({ error: 'Not connected to QuickBooks' });
      }

      const items = await queryQuickBooks(qb, 'findItems', {
        Active: true,
        limit: 100,
      });

      res.json({
        data: items.QueryResponse?.Item || [],
        count: items.QueryResponse?.Item?.length || 0,
      });
    } catch (error) {
      console.error('Fetch items error:', error);
      res.status(500).json({ error: 'Failed to fetch items' });
    }
  });

  // Fetch accounts (Chart of Accounts)
  app.get("/api/data/accounts", async (req, res) => {
    try {
      const qb = await getQuickBooksClient();
      
      if (!qb) {
        return res.status(401).json({ error: 'Not connected to QuickBooks' });
      }

      const accounts = await queryQuickBooks(qb, 'findAccounts', {
        Active: true,
        limit: 100,
      });

      res.json({
        data: accounts.QueryResponse?.Account || [],
        count: accounts.QueryResponse?.Account?.length || 0,
      });
    } catch (error) {
      console.error('Fetch accounts error:', error);
      res.status(500).json({ error: 'Failed to fetch accounts' });
    }
  });

  // Fetch vendors
  app.get("/api/data/vendors", async (req, res) => {
    try {
      const qb = await getQuickBooksClient();
      
      if (!qb) {
        return res.status(401).json({ error: 'Not connected to QuickBooks' });
      }

      const vendors = await queryQuickBooks(qb, 'findVendors', {
        Active: true,
        limit: 100,
      });

      res.json({
        data: vendors.QueryResponse?.Vendor || [],
        count: vendors.QueryResponse?.Vendor?.length || 0,
      });
    } catch (error) {
      console.error('Fetch vendors error:', error);
      res.status(500).json({ error: 'Failed to fetch vendors' });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
```

---

## Common Errors & Solutions

### Error 1: `QuickBooks.authorizeUrl is not a function`

**Cause**: The `authorizeUrl` method doesn't exist as a static method on the QuickBooks class.

**Solution**: Manually construct the OAuth URL:
```typescript
export function getAuthUri() {
  const state = Math.random().toString(36).substring(7);
  const scope = 'com.intuit.quickbooks.accounting';
  const baseUrl = 'https://appcenter.intuit.com/connect/oauth2';
  
  const params = new URLSearchParams({
    client_id: CLIENT_ID,
    scope,
    redirect_uri: REDIRECT_URI,
    response_type: 'code',
    state,
  });
  
  return `${baseUrl}?${params.toString()}`;
}
```

### Error 2: `redirect_uri is invalid`

**Cause**: Redirect URI mismatch between your code and QuickBooks settings.

**Solution**: 
1. Check your `QUICKBOOKS_REDIRECT_URI` secret value
2. Go to QuickBooks Developer Portal → Keys & credentials → Redirect URIs
3. Ensure they match EXACTLY (including https://, path, no trailing slash)

### Error 3: `Missing authorization code or realm ID`

**Cause**: OAuth callback didn't receive expected query parameters.

**Solution**: Check that your redirect URI is correct and the OAuth flow completed successfully.

### Error 4: Token refresh failures

**Cause**: Refresh token expired (100 days) or was revoked.

**Solution**: User needs to re-authenticate. Delete stored token and reconnect.

### Error 5: `findCustomers is not a function` or similar

**Cause**: Wrong method name or QuickBooks client not properly initialized.

**Solution**: Use the correct SDK method names:
- `findCustomers` (not `getCustomers`)
- `findInvoices` (not `getInvoices`)
- `findAccounts` (not `getAccounts`)
- `getCompanyInfo` (takes realmId as parameter)

---

## Testing the Integration

### Test OAuth Connect Endpoint
```bash
curl http://localhost:5000/api/oauth/connect
```

Expected response:
```json
{
  "authUri": "https://appcenter.intuit.com/connect/oauth2?client_id=...&scope=...&redirect_uri=...&response_type=code&state=..."
}
```

### Test Connection Status
```bash
curl http://localhost:5000/api/connection/status
```

Before connecting:
```json
{ "connected": false }
```

After connecting:
```json
{
  "connected": true,
  "companyName": "Sandbox Company_US_1",
  "realmId": "4620816365213353720",
  "lastSync": "2024-12-01T10:30:00.000Z"
}
```

---

## Available API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/oauth/connect` | GET | Returns OAuth authorization URL |
| `/api/oauth/callback` | GET | Handles OAuth callback (automatic redirect) |
| `/api/connection/status` | GET | Returns connection status and company info |
| `/api/connection/disconnect` | POST | Disconnects from QuickBooks |
| `/api/data/customers` | GET | Fetches customer list |
| `/api/data/invoices` | GET | Fetches invoice list |
| `/api/data/items` | GET | Fetches products/services |
| `/api/data/accounts` | GET | Fetches chart of accounts |
| `/api/data/vendors` | GET | Fetches vendor list |

---

## Production Deployment

### Checklist

1. **Update Environment**:
   ```typescript
   const ENVIRONMENT = 'production';
   ```

2. **Update Redirect URI**:
   - Change `QUICKBOOKS_REDIRECT_URI` to production domain
   - Add production URI to QuickBooks Developer Portal

3. **Submit App for Review**:
   - Production apps require Intuit approval
   - Go to Developer Portal → Your App → Get production keys

4. **Security Considerations**:
   - Use database storage instead of in-memory (MemStorage)
   - Implement HTTPS (automatic on Replit)
   - Add rate limiting
   - Validate state parameter for CSRF protection

### Custom Domain Setup

If using a custom domain (e.g., `flow.growth.accountants`):

1. Set up CNAME in your domain registrar pointing to Replit
2. Add domain in Replit's Deployments → Settings → Link a domain
3. Update `QUICKBOOKS_REDIRECT_URI` to:
   ```
   https://flow.growth.accountants/api/oauth/callback
   ```
4. Add this URI to QuickBooks Developer Portal whitelist

---

## Additional QuickBooks API Methods

The `node-quickbooks` SDK supports these methods:

### Queries
- `findCustomers`, `findInvoices`, `findBills`, `findVendors`
- `findAccounts`, `findItems`, `findPayments`
- `findPurchases`, `findJournalEntries`, `findTransfers`

### Single Record
- `getCustomer`, `getInvoice`, `getBill`, `getVendor`
- `getCompanyInfo` (requires realmId as parameter)

### Reports
- `reportProfitAndLoss`, `reportBalanceSheet`
- `reportTrialBalance`, `reportCashFlow`
- `reportAgedReceivables`, `reportAgedPayables`

### Example: Fetching P&L Report
```typescript
app.get("/api/reports/profit-loss", async (req, res) => {
  const qb = await getQuickBooksClient();
  
  if (!qb) {
    return res.status(401).json({ error: 'Not connected' });
  }

  const report = await queryQuickBooks(qb, 'reportProfitAndLoss', {
    start_date: '2024-01-01',
    end_date: '2024-12-31',
    accounting_method: 'Accrual',
  });

  res.json(report);
});
```

---

## Quick Reference: Query Options

```typescript
// Common query options for find* methods
{
  Active: true,           // Filter active only
  limit: 100,             // Max records (default 100, max 1000)
  offset: 0,              // Pagination offset
  asc: 'DisplayName',     // Sort ascending
  desc: 'MetaData.LastUpdatedTime', // Sort descending
  fetchAll: true,         // Auto-paginate all records
}
```

---

## Troubleshooting Checklist

- [ ] `node-quickbooks` package installed
- [ ] All 4 secrets configured in Replit
- [ ] Redirect URI matches exactly in code and QuickBooks portal
- [ ] Using correct SDK method names (findX, not getX)
- [ ] `@ts-ignore` on QuickBooks import (no types available)
- [ ] Using `ENVIRONMENT = 'sandbox'` for testing
- [ ] OAuth callback redirects to frontend after success

---

## Support Resources

- **QuickBooks API Docs**: https://developer.intuit.com/app/developer/qbo/docs/api/accounting/all-entities
- **node-quickbooks GitHub**: https://github.com/mcohen01/node-quickbooks
- **OAuth 2.0 Guide**: https://developer.intuit.com/app/developer/qbo/docs/develop/authentication-and-authorization
